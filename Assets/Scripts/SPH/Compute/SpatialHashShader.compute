#pragma kernel CSMain
#pragma kernel ClearGrid
#pragma kernel SortParticles

// Constants
static const uint HASH_TABLE_SIZE = 262144; // 2^18
static const float3 GRID_OFFSET = float3(4096, 4096, 4096);

// Particle data
struct Particle
{
    float3 position;
    float3 velocity;
    float density;
    float pressure;
    uint id;
};

// Hash cell structure
struct HashCell
{
    uint particleCount;
    uint startIndex;
};

// Buffers
RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<HashCell> hashGrid;
RWStructuredBuffer<uint> particleGridIndices;
RWStructuredBuffer<uint> cellOffsets;

// Parameters
uint numParticles;
float smoothingRadius;
float3 boundsMin;
float3 boundsMax;

// Hash function for 3D positions
uint Hash3D(int3 cell)
{
    uint h1 = (uint)(cell.x * 73856093);
    uint h2 = (uint)(cell.y * 19349663);
    uint h3 = (uint)(cell.z * 83492791);
    return (h1 ^ h2 ^ h3) % HASH_TABLE_SIZE;
}

// Convert world position to grid cell
int3 PositionToCell(float3 position)
{
    return int3(floor((position - boundsMin) / smoothingRadius));
}

// Clear grid kernel
[numthreads(64, 1, 1)]
void ClearGrid(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= HASH_TABLE_SIZE) return;
    
    hashGrid[id.x].particleCount = 0;
    hashGrid[id.x].startIndex = 0;
}

// Main spatial hashing kernel
[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint particleIndex = id.x;
    if (particleIndex >= numParticles) return;
    
    // Get particle position
    float3 position = particles[particleIndex].position;
    
    // Calculate grid cell
    int3 cell = PositionToCell(position);
    
    // Hash the cell
    uint hashValue = Hash3D(cell);
    
    // Atomically increment particle count for this cell
    uint originalCount;
    InterlockedAdd(hashGrid[hashValue].particleCount, 1, originalCount);
    
    // Store particle index and hash for sorting
    particleGridIndices[particleIndex] = particleIndex;
    cellOffsets[particleIndex] = hashValue;
}

// Sorting kernel to organize particles by hash value
[numthreads(64, 1, 1)]
void SortParticles(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= numParticles) return;
    
    // Simple insertion sort for each hash bucket
    // In practice, you'd want to use a more efficient sorting algorithm
    uint currentHash = cellOffsets[index];
    uint currentParticle = particleGridIndices[index];
    
    // Find insertion position
    for (uint i = 0; i < index; i++)
    {
        if (cellOffsets[i] > currentHash)
        {
            // Shift elements
            for (uint j = index; j > i; j--)
            {
                cellOffsets[j] = cellOffsets[j - 1];
                particleGridIndices[j] = particleGridIndices[j - 1];
            }
            
            // Insert current element
            cellOffsets[i] = currentHash;
            particleGridIndices[i] = currentParticle;
            break;
        }
    }
}

// Additional helper functions for neighbor finding
uint GetHashKey(float3 position)
{
    int3 cell = PositionToCell(position);
    return Hash3D(cell);
}

// Function to get neighboring cells (used by other shaders)
void GetNeighborCells(float3 position, out uint neighborHashes[27])
{
    int3 cell = PositionToCell(position);
    uint index = 0;
    
    // Check all 27 neighboring cells (3x3x3 cube)
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            for (int z = -1; z <= 1; z++)
            {
                int3 neighborCell = cell + int3(x, y, z);
                neighborHashes[index++] = Hash3D(neighborCell);
            }
        }
    }
}